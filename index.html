<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar System 3D — Clay Style</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; }
    body { margin: 0; overflow: hidden; background:#fff7f0; }
    canvas { display:block; }

    /* Logo (optionnel) */
    #siteLogo {
      position:absolute; top:16px; left:16px;
      width:80px; height:auto; z-index:10; pointer-events:none;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,.15));
    }

    /* Petit bouton d'accessibilité pour basculer les couleurs (optionnel) */
    #palette {
      position: absolute; top:16px; right:16px; z-index:10;
      padding:10px 14px; border-radius:999px; border:none; cursor:pointer;
      background:#111; color:#fff; font:600 14px system-ui, -apple-system, Arial;
      box-shadow:0 6px 16px rgba(17,17,17,.25);
    }
  </style>
</head>
<link rel="icon" type="image/png" href="textures/bonlogo.png">

<body>
  <!-- Optionnel: <img id="siteLogo" src="textures/bonlogo.png" alt=""> -->
  <button id="palette" aria-label="Switch color scheme">Swap palette</button>

  <!-- Three.js local -->
  <script src="three.min.js"></script>
  <script>
  // =========================
  //  Clay / Toon helpers
  // =========================

  // Palette douce "clay"
  const PALETTES = [
    {
      sun:   0xFFD93B,
      skyA:  '#fff7f0', skyB: '#f9e2ae',
      orbit: [0xA64AC9, 0x00BCD4, 0x8BC34A],
      planets: [0x40CFFF, 0xFF6F91, 0x8DE969, 0xFFB26B]
    },
    {
      sun:   0xFFB703,
      skyA:  '#f6f4ff', skyB: '#dfe5ff',
      orbit: [0x6C63FF, 0x00BFA6, 0xFF6584],
      planets: [0x86E3CE, 0xFFDD94, 0xCCABDB, 0xF9A1BC]
    }
  ];
  let paletteIndex = 0;

  // Gradient map pour MeshToonMaterial (4 niveaux)
  function makeToonGradientMap(steps = 4){
    const c = document.createElement('canvas');
    c.width = steps; c.height = 1;
    const ctx = c.getContext('2d');
    const g = ctx.createLinearGradient(0,0,steps,0);
    g.addColorStop(0.00, '#ffffff');
    g.addColorStop(0.50, '#cfcfcf');
    g.addColorStop(0.80, '#9a9a9a');
    g.addColorStop(1.00, '#6b6b6b');
    ctx.fillStyle = g; ctx.fillRect(0,0,steps,1);
    const tex = new THREE.CanvasTexture(c);
    tex.minFilter = THREE.NearestFilter;
    tex.magFilter = THREE.NearestFilter;
    tex.generateMipmaps = false;
    return tex;
  }
  const toonGradient = makeToonGradientMap(4);

  // Texture "plastique" douce via canvas (couleur + léger highlight peint)
  function makeClayTexture(hexColor){
    const c = document.createElement('canvas');
    c.width = c.height = 512;
    const ctx = c.getContext('2d');

    // base
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,512,512);

    // aplat principal
    ctx.fillStyle = '#000';
    const col = new THREE.Color(hexColor);
    // dégradé radial subtil
    const g = ctx.createRadialGradient(256,200,60, 256,256,280);
    g.addColorStop(0, col.clone().offsetHSL(0, -0.05, 0.25).getStyle());
    g.addColorStop(1, col.getStyle());
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(256,256,240,0,Math.PI*2); ctx.fill();

    // petit "glacis" plastique
    const h = ctx.createRadialGradient(200,170,10, 200,170,120);
    h.addColorStop(0,'rgba(255,255,255,.55)');
    h.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = h;
    ctx.beginPath(); ctx.arc(200,170,120,0,Math.PI*2); ctx.fill();

    return new THREE.CanvasTexture(c);
  }

  // Halo sprite (pour Soleil)
  function makeGlowSprite(hex, size=420, alpha=0.55){
    const c = document.createElement('canvas'); c.width = c.height = 512;
    const ctx = c.getContext('2d');
    const g = ctx.createRadialGradient(256,256,40,256,256,250);
    const base = new THREE.Color(hex).getStyle();
    ctx.globalCompositeOperation = 'source-over';
    g.addColorStop(0.00, base.replace('rgb','rgba').replace(')',`,${alpha})`));
    g.addColorStop(0.35, base.replace('rgb','rgba').replace(')',`,${alpha*0.6})`));
    g.addColorStop(0.70, base.replace('rgb','rgba').replace(')',`,${alpha*0.25})`));
    g.addColorStop(1.00, 'rgba(255,255,255,0)');
    ctx.fillStyle = g; ctx.fillRect(0,0,512,512);
    const tex = new THREE.CanvasTexture(c);
    const mat = new THREE.SpriteMaterial({
      map: tex, transparent:true, depthWrite:false, depthTest:false,
      blending: THREE.AdditiveBlending
    });
    const spr = new THREE.Sprite(mat);
    spr.scale.set(size,size,1);
    spr.renderOrder = 999;
    return spr;
  }

  // Bulle label style appli
  function makeBubbleLabel(text, planetRadius){
    const W=256,H=96,r=18,tailW=22,tailH=12;
    const cvs=document.createElement('canvas'); cvs.width=W; cvs.height=H+tailH;
    const ctx=cvs.getContext('2d');

    ctx.fillStyle='rgba(50,50,50,0.80)';
    ctx.beginPath();
    ctx.moveTo(r,0); ctx.lineTo(W-r,0); ctx.quadraticCurveTo(W,0,W,r);
    ctx.lineTo(W,H-r); ctx.quadraticCurveTo(W,H,W-r,H);
    ctx.lineTo(56+tailW,H); ctx.lineTo(56,H+tailH); ctx.lineTo(56-tailW,H);
    ctx.lineTo(r,H); ctx.quadraticCurveTo(0,H,0,H-r);
    ctx.lineTo(0,r); ctx.quadraticCurveTo(0,0,r,0); ctx.closePath(); ctx.fill();

    ctx.font='bold 30px system-ui, Arial';
    ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(text,W/2,H/2);

    const tex=new THREE.CanvasTexture(cvs);
    const spr=new THREE.Sprite(new THREE.SpriteMaterial({ map:tex, transparent:true }));
    spr.scale.set(planetRadius*3.0, planetRadius*1.05, 1);
    return spr;
  }

  // Fond ciel pastel avec quelques points
  function makePastelSky(a='#fff7f0', b='#f9e2ae'){
    const c = document.createElement('canvas'); c.width = 1024; c.height = 1024;
    const ctx = c.getContext('2d');
    const g = ctx.createRadialGradient(512,512,50,512,512,700);
    g.addColorStop(0, a);
    g.addColorStop(1, b);
    ctx.fillStyle = g; ctx.fillRect(0,0,1024,1024);

    // quelques pastilles blanches douces
    for(let i=0;i<180;i++){
      const x = Math.random()*1024, y = Math.random()*1024;
      const r = Math.random()*2.2 + 0.8;
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    }
    const tex = new THREE.CanvasTexture(c);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(2,2);
    return tex;
  }

  // =========================
  //   Scene / Camera / Renderer
  // =========================
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 3000);
  camera.position.set(0, 120, 520);
  camera.lookAt(0,0,0);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  // =========================
  //   Fond “ciel”
  // =========================
  let starField;
  function applySkyTexture(){
    if (starField) scene.remove(starField);
    const skyTex = makePastelSky(PALETTES[paletteIndex].skyA, PALETTES[paletteIndex].skyB);
    const skyGeo = new THREE.SphereGeometry(2000, 64, 64);
    const skyMat = new THREE.MeshBasicMaterial({ map: skyTex, side: THREE.BackSide });
    starField = new THREE.Mesh(skyGeo, skyMat);
    scene.add(starField);
  }
  applySkyTexture();

  // =========================
  //   Lumières
  // =========================
  const ambient = new THREE.AmbientLight(0xffffff, 0.45);
  scene.add(ambient);

  const keyLight = new THREE.DirectionalLight(0xffffff, 1.25);
  keyLight.position.set(220, 260, 140);
  keyLight.castShadow = true;
  keyLight.shadow.mapSize.set(2048,2048);
  scene.add(keyLight);

  // =========================
  //   Soleil (toon + halo)
  // =========================
  let sun, sunGlow;
  function buildSun(){
    if (sun) { scene.remove(sun); }
    const col = PALETTES[paletteIndex].sun;
    const sunMat = new THREE.MeshToonMaterial({
      color: col,
      gradientMap: toonGradient
    });
    const sunTex = makeClayTexture(col);
    sunMat.map = sunTex;

    sun = new THREE.Mesh(new THREE.SphereGeometry(55, 64, 64), sunMat);
    sun.castShadow = false; sun.receiveShadow = false;
    scene.add(sun);

    // halo
    if (sunGlow) sun.remove(sunGlow);
    sunGlow = makeGlowSprite(col, 460, 0.55);
    sun.add(sunGlow);
  }
  buildSun();

  // =========================
  //   Planètes / Orbites / Labels
  // =========================
  const planets = [];
  const ORBIT_SEGMENTS = 360;

  const planetData = [
    { label:'OUTREACH', name:'N1', size:14, distance:150, speed:0.006, ellipse:0.75 },
    { label:'PERSONAL', name:'V1', size:18, distance:220, speed:0.004, ellipse:0.78 },
    { label:'RESEARCH', name:'E1', size:20, distance:280, speed:0.003, ellipse:0.80 }
  ];

  function buildSystem(){
    // reset
    planets.splice(0, planets.length);

    // supprimer anciennes orbites si on re-bâtit
    for (let i=scene.children.length-1;i>=0;i--){
      const o = scene.children[i];
      if (o.userData && o.userData.isOrbit) scene.remove(o);
    }

    const orbitColors = PALETTES[paletteIndex].orbit;
    const planetColors = PALETTES[paletteIndex].planets;

    planetData.forEach((d, idx)=>{
      // Matériau toon + texture plastique
      const baseCol = planetColors[idx % planetColors.length];
      const tex = makeClayTexture(baseCol);
      const mat = new THREE.MeshToonMaterial({
        color: baseCol,
        gradientMap: toonGradient,
        map: tex
      });

      const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(d.size, 64, 64),
        mat
      );
      mesh.castShadow = true; mesh.receiveShadow = false;
      mesh.userData = { angle: Math.random()*Math.PI*2, speed:d.speed, distance:d.distance, ellipse:d.ellipse };
      scene.add(mesh);

      // Label bulle
      const label = makeBubbleLabel(d.label, d.size);
      scene.add(label);

      // Orbite (LineLoop stylisé)
      const positions = new Float32Array(ORBIT_SEGMENTS * 3);
      for (let i=0; i<ORBIT_SEGMENTS; i++){
        const t = (i / ORBIT_SEGMENTS) * Math.PI * 2;
        positions[i*3+0] = Math.cos(t) * d.distance;
        positions[i*3+1] = 0;
        positions[i*3+2] = Math.sin(t) * d.distance * d.ellipse;
      }
      const orbitGeo = new THREE.BufferGeometry();
      orbitGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const orbitMat = new THREE.LineBasicMaterial({
        color: orbitColors[idx%orbitColors.length],
        transparent:true, opacity:0.95
      });
      const orbit = new THREE.LineLoop(orbitGeo, orbitMat);
      orbit.userData.isOrbit = true;
      scene.add(orbit);

      planets.push({ mesh, label, data:d });
    });
  }
  buildSystem();

  // =========================
  //   Resize
  // =========================
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // =========================
  //   Animation
  // =========================
  function animate(){
    requestAnimationFrame(animate);
    if (starField) starField.rotation.y += 0.00012;

    planets.forEach(p=>{
      const u = p.mesh.userData;
      // mouvement doux type “jouet” : vitesse sinusée
      u.angle += u.speed * (1.0 + 0.05*Math.sin(performance.now()*0.001));
      const x = Math.cos(u.angle)*u.distance;
      const z = Math.sin(u.angle)*u.distance*u.ellipse;
      p.mesh.position.set(x, 0, z);

      // bulle au-dessus de la planète
      const bubbleHalfH = p.data.size * 0.35 * 0.5;
      p.label.position.set(x, p.data.size + bubbleHalfH + 6, z);
    });

    renderer.render(scene, camera);
  }
  animate();

  // =========================
  //   Palette switch (optionnel)
  // =========================
  document.getElementById('palette').addEventListener('click', ()=>{
    paletteIndex = (paletteIndex + 1) % PALETTES.length;
    // fond ciel
    applySkyTexture();
    // soleil + halo
    buildSun();
    // systèmes (planètes / orbites)
    buildSystem();
  });

  </script>
</body>
</html>
