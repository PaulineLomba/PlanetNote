<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar System 3D</title>
  <style>
    html, body { height: 100%; }
    body { margin: 0; overflow: hidden; background:#000; }
    canvas { display:block; }
  </style>
</head>
<body>
    
  <script src="three.min.js"></script>
  <script>
  // --- Scene / Camera / Renderer
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 3000);
  camera.position.set(0, 120, 450);
  camera.lookAt(0,0,0);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const loader = new THREE.TextureLoader();

  // --- Soleil + halo doux
  const loader = new THREE.TextureLoader();

  // Soleil texturé (garde MeshBasicMaterial pour un rendu bien “émissif”)
  const sun = new THREE.Mesh(
    new THREE.SphereGeometry(55, 64, 64),
    new THREE.MeshBasicMaterial({ map: loader.load('textures/sun.jpg') })
  );
  scene.add(sun);
  
  // Petit boost de lumière perçue (optionnel) :
  // si tu préfères, utilise plutôt MeshStandardMaterial pour pouvoir jouer avec 'emissive'
  // const sun = new THREE.Mesh(
  //   new THREE.SphereGeometry(55, 64, 64),
  //   new THREE.MeshStandardMaterial({
  //     map: loader.load('textures/sun.jpg'),
  //     emissive: 0xFFB300,
  //     emissiveIntensity: 0.6
  //   })
  // );
  
  // Halo : sprite à gradient radial en additive blending (doux & large)
  function makeGlowSprite(hexColor = 0xffcc33, size = 360, opacity = 0.55) {
    const c = document.createElement('canvas');
    c.width = c.height = 512;
    const ctx = c.getContext('2d');
  
    const g = ctx.createRadialGradient(256, 256, 40, 256, 256, 250);
    // centre très lumineux -> bords transparents
    g.addColorStop(0.0, 'rgba(255, 220, 100, 1.0)');
    g.addColorStop(0.35,'rgba(255, 200, 80, 0.7)');
    g.addColorStop(0.7, 'rgba(255, 180, 40, 0.25)');
    g.addColorStop(1.0, 'rgba(255, 160, 0, 0.0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,512,512);
  
    const tex = new THREE.CanvasTexture(c);
    const mat = new THREE.SpriteMaterial({
      map: tex,
      color: hexColor,
      transparent: true,
      opacity: opacity,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    const spr = new THREE.Sprite(mat);
    spr.scale.set(size, size, 1); // taille du halo
    spr.renderOrder = -1;         // derrière tout pour éviter de “manger” les labels
    return spr;
  }
  
  // ajoute le halo au centre
  const sunGlow = makeGlowSprite(0xffd25a, 420, 0.55);
  sun.add(sunGlow); // le halo suit le Soleil


  // --- Planètes (vitesses lentes)
  const planets = [];
  const planetData = [
    { label:'OUTREACH', name:'Neptune', size:12, distance:140, speed:0.006, tex:'textures/neptune.jpg', ellipse:0.75 },
    { label:'PERSONAL', name:'Venus',   size:16, distance:190, speed:0.004, tex:'textures/venus.jpg',   ellipse:0.78 },
    { label:'RESEARCH', name:'Earth',   size:18, distance:240, speed:0.003, tex:'textures/earth.jpg',   ellipse:0.8  }
  ];

  // --- bulle "étiquette" semi-transparente
  function makeBubbleLabel(text){
    const w=360,h=120,r=18,tailW=40,tailH=28;
    const cvs=document.createElement('canvas'); cvs.width=w; cvs.height=h+tailH;
    const ctx=cvs.getContext('2d');
    ctx.fillStyle='rgba(80,80,80,0.75)';
    ctx.beginPath();
    ctx.moveTo(r,0); ctx.lineTo(w-r,0); ctx.quadraticCurveTo(w,0,w,r);
    ctx.lineTo(w,h-r); ctx.quadraticCurveTo(w,h,w-r,h);
    ctx.lineTo(60+tailW,h); ctx.lineTo(60,h+tailH); ctx.lineTo(60-tailW,h);
    ctx.lineTo(r,h); ctx.quadraticCurveTo(0,h,0,h-r);
    ctx.lineTo(0,r); ctx.quadraticCurveTo(0,0,r,0); ctx.closePath(); ctx.fill();
    ctx.font='bold 48px system-ui, Arial'; ctx.fillStyle='#fff';
    ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(text,w/2,h/2);
    const tex=new THREE.CanvasTexture(cvs);
    const spr=new THREE.Sprite(new THREE.SpriteMaterial({ map:tex, transparent:true }));
    spr.scale.set(140,55,1);
    return spr;
  }

  // --- Lumières
  scene.add(new THREE.AmbientLight(0xffffff, 0.35));
  scene.add(new THREE.PointLight(0xffffff, 1.4));

  // --- Création planètes + orbites dégradées + labels
  const ORBIT_SEGMENTS = 256; // finesse des ellipses

  planetData.forEach(d=>{
    // planète
    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(d.size,32,32),
      new THREE.MeshStandardMaterial({ map: loader.load(d.tex) })
    );
    mesh.userData = { angle: Math.random()*Math.PI*2, speed:d.speed, distance:d.distance, ellipse:d.ellipse };
    scene.add(mesh);

    // étiquette
    const label = makeBubbleLabel(d.label);
    scene.add(label);

    // ORBITE FIXE EN DÉGRADÉ (LineLoop + vertexColors)
    const pos = new Float32Array(ORBIT_SEGMENTS * 3);
    const col = new Float32Array(ORBIT_SEGMENTS * 3);

    for (let i=0; i<ORBIT_SEGMENTS; i++){
      const t = (i / ORBIT_SEGMENTS) * Math.PI * 2;     // angle
      const x = Math.cos(t) * d.distance;
      const z = Math.sin(t) * d.distance * d.ellipse;   // aplatissement -> ellipse
      const y = 0;

      // position
      pos[i*3+0] = x; pos[i*3+1] = y; pos[i*3+2] = z;

      // dégradé fixe le long de l'orbite (ancien -> sombre, récent -> clair)
      // tu peux inverser (1-g) si tu préfères l'autre sens
      const g = 0.25 + 0.75 * (i / (ORBIT_SEGMENTS-1)); // 0.25..1.0
      col[i*3+0] = g; col[i*3+1] = g; col[i*3+2] = g;
    }

    const orbitGeo = new THREE.BufferGeometry();
    orbitGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    orbitGeo.setAttribute('color',    new THREE.BufferAttribute(col,3));

    const orbitMat = new THREE.LineBasicMaterial({ vertexColors:true, transparent:true, opacity:0.85 });
    const orbit    = new THREE.LineLoop(orbitGeo, orbitMat);
    scene.add(orbit);

    planets.push({ mesh, label, data:d });
  });

  // --- Resize
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // --- Animation (planètes lentes + labels par-dessus)
  function animate(){
    requestAnimationFrame(animate);

    planets.forEach(p=>{
      const u = p.mesh.userData;
      u.angle += u.speed;

      const x = Math.cos(u.angle)*u.distance;
      const z = Math.sin(u.angle)*u.distance*u.ellipse;
      const y = 0;

      p.mesh.position.set(x,y,z);
      p.label.position.set(x, p.data.size + 24, z);
    });

    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>
