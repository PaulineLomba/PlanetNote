<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar System 3D</title>
  <style>
    html, body { height: 100%; }
    body { margin: 0; overflow: hidden; background:#000; }
    canvas { display:block; }
  </style>
</head>
<body>
  <script src="three.min.js"></script>

  <script>
  // --- Scene / Camera / Renderer
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 3000);
  camera.position.set(0, 120, 450);
  camera.lookAt(0,0,0);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const loader = new THREE.TextureLoader();

  // --- Soleil
  const sun = new THREE.Mesh(
    new THREE.SphereGeometry(55, 64, 64),
    new THREE.MeshBasicMaterial({ map: loader.load('textures/sun.jpg') })
  );
  scene.add(sun);

  // --- Halo doux
  (function addSunGlow(){
    const c = document.createElement('canvas');
    c.width = c.height = 512;
    const ctx = c.getContext('2d');
    const g = ctx.createRadialGradient(256,256,40,256,256,250);
    g.addColorStop(0.00,'rgba(255,230,120,1.0)');
    g.addColorStop(0.35,'rgba(255,210,90,0.7)');
    g.addColorStop(0.70,'rgba(255,190,50,0.25)');
    g.addColorStop(1.00,'rgba(255,170,0,0.0)');
    ctx.fillStyle = g; ctx.fillRect(0,0,512,512);
    const tex = new THREE.CanvasTexture(c);
    const mat = new THREE.SpriteMaterial({
      map: tex, color: 0xffd25a, transparent: true, opacity: 0.55,
      blending: THREE.AdditiveBlending, depthWrite: false, depthTest: false
    });
    const glow = new THREE.Sprite(mat);
    glow.scale.set(420,420,1); glow.renderOrder = 999;
    sun.add(glow);
  })();

  // --- Planètes
  const planets = [];
  const planetData = [
    { label:'OUTREACH', name:'Neptune', size:12, distance:150, speed:0.006, tex:'textures/neptune.jpg', ellipse:0.75 },
    { label:'PERSONAL', name:'Venus',   size:16, distance:250, speed:0.004, tex:'textures/venus.jpg',   ellipse:0.78 },
    { label:'RESEARCH', name:'Earth',   size:18, distance:300, speed:0.003, tex:'textures/earth.jpg',   ellipse:0.80 }
  ];

  // Étiquette auto-scalée (~1.5× diamètre)
  function makeBubbleLabel(text, planetRadius){
    const W=256,H=96,r=14,tailW=22,tailH=12;
    const cvs=document.createElement('canvas'); cvs.width=W; cvs.height=H+tailH;
    const ctx=cvs.getContext('2d');
    ctx.fillStyle='rgba(80,80,80,0.75)';
    ctx.beginPath();
    ctx.moveTo(r,0); ctx.lineTo(W-r,0); ctx.quadraticCurveTo(W,0,W,r);
    ctx.lineTo(W,H-r); ctx.quadraticCurveTo(W,H,W-r,H);
    ctx.lineTo(50+tailW,H); ctx.lineTo(50,H+tailH); ctx.lineTo(50-tailW,H);
    ctx.lineTo(r,H); ctx.quadraticCurveTo(0,H,0,H-r);
    ctx.lineTo(0,r); ctx.quadraticCurveTo(0,0,r,0); ctx.closePath(); ctx.fill();
    ctx.font='bold 30px system-ui, Arial'; ctx.fillStyle='#fff';
    ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(text,W/2,H/2);
    const tex=new THREE.CanvasTexture(cvs);
    const spr=new THREE.Sprite(new THREE.SpriteMaterial({ map:tex, transparent:true }));
    const widthWorld  = planetRadius * 3.0;  // 1.5× diamètre
    const heightWorld = planetRadius * 1.05;
    spr.scale.set(widthWorld, heightWorld, 1);
    return spr;
  }

  // Lumières
  scene.add(new THREE.AmbientLight(0xffffff, 0.35));
  scene.add(new THREE.PointLight(0xffffff, 1.4));

  // Traînée — paramètres
  const TRAIL_MAX = 220; // nb de points (augmenter pour plus long)

  planetData.forEach(d=>{
    // planète
    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(d.size,32,32),
      new THREE.MeshStandardMaterial({ map: loader.load(d.tex) })
    );
    mesh.userData = { angle: Math.random()*Math.PI*2, speed:d.speed, distance:d.distance, ellipse:d.ellipse };
    scene.add(mesh);

    // label
    const label = makeBubbleLabel(d.label, d.size);
    scene.add(label);

    // --- traînée (polyline unique, pas de rayons)
    const positions = new Float32Array(TRAIL_MAX * 3);
    const colors    = new Float32Array(TRAIL_MAX * 3);
    for (let i=0;i<TRAIL_MAX;i++){
      const t = i / (TRAIL_MAX - 1);            // ancien -> récent
      const c = 0.20 + 0.80 * t;                // sombre -> blanc
      colors[i*3+0]=c; colors[i*3+1]=c; colors[i*3+2]=c;
    }
    const trailGeo = new THREE.BufferGeometry();
    trailGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
    trailGeo.setAttribute('color',    new THREE.BufferAttribute(colors,3));
    trailGeo.setDrawRange(0, 1); // on commence avec 1 point

    const trailMat = new THREE.LineBasicMaterial({ vertexColors:true, transparent:true, opacity:0.9 });
    const trail = new THREE.Line(trailGeo, trailMat);
    scene.add(trail);

    planets.push({
      mesh, label, data:d,
      trailGeo, trailPos:positions, trailCount:0
    });
  });

  // Resize
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Animation
  function animate(){
    requestAnimationFrame(animate);

    planets.forEach(p=>{
      const u = p.mesh.userData;
      u.angle += u.speed;

      const x = Math.cos(u.angle)*u.distance;
      const z = Math.sin(u.angle)*u.distance*u.ellipse;
      const y = 0;

      // planète
      p.mesh.position.set(x,y,z);

      // label (au-dessus)
      const bubbleHalfH = p.data.size * 1.05 * 0.5;
      p.label.position.set(x, p.data.size + bubbleHalfH + 6, z);

      // --- TRAÎNÉE SANS RAYONS ---
      // décale tout vers la gauche de 1 point
      if (p.trailCount >= TRAIL_MAX) {
        p.trailPos.copyWithin(0, 3);
        // écrit le nouveau point en fin
        p.trailPos.set([x,y,z], p.trailPos.length - 3);
      } else {
        // remplit progressivement le début du buffer
        p.trailPos.set([x,y,z], p.trailCount * 3);
        p.trailCount++;
      }

      // met à jour uniquement la partie utile et la longueur dessinée
      p.trailGeo.attributes.position.needsUpdate = true;
      p.trailGeo.setDrawRange(0, Math.max(2, p.trailCount));
    });

    renderer.render(scene, camera);
  }
  animate();
  </script>
</body>
</html>
